#!/usr/bin/python
# -*- coding: utf-8 -*-

"""
==============================================================================================
05 plot_cluster.py
functions that convert the clusters clusters.py generates
into 2D arrays with MDS or PCA and scatterplot them;
to be called by cluster.py
 - Qian Yang (qyang1@cs.cmu.edu)
 - References:
 - http://brandonrose.org/clustering
 - stackoverflow.com/questions/28160335/plot-a-document-tfidf-2d-graph
 - https://joernhees.de/blog/2015/08/26/scipy-hierarchical-clustering-and-dendrogram-tutorial/
 - https://gist.github.com/mdml/7537455
==============================================================================================
"""

from sklearn.manifold import MDS
from sklearn.decomposition import PCA
from scipy.cluster.hierarchy import ward, dendrogram, linkage, to_tree
import matplotlib.pyplot as plt
import matplotlib as mpl
import mpld3
import json
import numpy as np
import pandas as pd

# =========== transform & plot clusters ============== #

#colors for each cluster when plotting
cluster_colors = {0: '#2B3A42', # dark cold grey
                  1: '#3F5765',
                  2: '#A1B4BD',
                  3: '#FF530D',# bright orange
                  4: '#ED904A',
                  5: '#EDDAAB',
                  6: '#EDD984',
                  7: '#EDB760',
                  8: '#C4C4C4', # light neutral grey
                  9: '#BDD4DE' 
                 }

# method 1: multidimensional scaling (MDS)
def mds_(dist, km, num_clusters):
    global data2D
    global cluster_names
    global cluster_colors
    
    print("MDS starts...\n")
    # convert the dist matrix into a 2D array 
    # so as to later plot points in a two-dimensional plane
    MDS()
    mds = MDS(n_components=2, dissimilarity='precomputed', random_state=1)

    # convert the dist matrix into a 2D array 
    data2D = mds.fit_transform(dist)  # shape (n_components, n_samples)
    data2D.dump('js/data2D_mds.dat')
    
    # plot the converted data points
    plt.style.use('ggplot')
    # var. clusters is kmeans.labels_.tolist()
    plt.scatter(data2D[:,0], data2D[:,1], color= [cluster_colors[cluster] for cluster in km.labels_.tolist()])

    return plt

# method 2: principal component analysis (PCA)
def pca_(tfidf_matrix, km, num_clusters):
    global data2D
    
    # convert the dist matrix into a 2D array 
    pca = PCA(n_components=2, random_state=1)
    data2D = pca.fit_transform(tfidf_matrix.todense())
    data2D.dump('js/data2D_pca.dat')
    
    # convert cluster centroids too
    centers2D = pca.fit_transform(km.cluster_centers_[:,:5])
    
    plt.style.use('ggplot')
    # var. clusters is kmeans.labels_.tolist()
    plt.scatter(data2D[:,0], data2D[:,1], c= [cluster_colors[cluster] for cluster in km.labels_.tolist()]) 
    plt.hold(True)
    plt.scatter(centers2D[:,0], centers2D[:,1], marker='x', s=100, 
                color = [cluster_colors[cluster] for cluster in np.arange(num_clusters)],
                label = [cluster_names[cluster] for cluster in np.arange(num_clusters)])
    
    return plt


# =========== Hierarchical Clustering & Dendrograming ============== #
# reference: https://gist.github.com/mdml/7537455

# Create a nested dictionary from the ClusterNode's returned by SciPy
def add_node(node, parent):
    # First create the new node and append it to its parent's children
    newNode = dict(node_id=node.id, children=[])
    parent["children"].append( newNode )

    # Recursively add the current node's children
    if node.left:
        add_node(node.left, newNode)
    if node.right:
        add_node(node.right, newNode)

# Label each node with the names of each leaf in its subtree
def label_tree(n, id2name):
    # If the node is a leaf, then we have its name
    if len(n["children"]) == 0:
        leafNames = [id2name[n["node_id"]]]

    # If not, flatten all the leaves in the node's subtree
    else:
        leafNames = reduce(lambda ls, c: ls + label_tree(c, id2name),
                           n["children"], [])

    # Delete the node id since we don't need it anymore and
    # it makes for cleaner JSON
    del n["node_id"]

    # Labeling convention: "\n"-separated leaf names
    n["name"] = name = " + ".join(sorted(map(str, leafNames)))
    
    return leafNames
     

def dendrogram_(data2D, brief, method):
    """
    Takes in 
    returns a linkage matrix calculated from the 2D data generated by PCA or MDS ;
    and plots the matrix into a dendrogram;
    """

    linkage_matrix = linkage(data2D, 'ward')
    
    # Draw dendrogram using matplotlib
    fig = plt.figure()
    dpi = 130
    fig.set_size_inches((fig.get_size_inches()[0]*2, 32768/dpi)) # twice the width and maximize the fig height
    dendrogram(linkage_matrix,
               labels = brief,
               orientation = 'right',
               leaf_font_size = 7)
    plt.savefig("viz/scipy_dendro_%s.png" % method, bbox_inches='tight', dpi = dpi)
    
    return linkage_matrix

    
def dendro_to_json(linkage_matrix, fout, id2name):
    
    # construct a nested dict to represent the dendro
    T = to_tree(linkage_matrix, rd=False)
    d3Dendro = dict(children=[], name="Root1")
    add_node(T, d3Dendro)
    
    # label the dendro
    label_tree(d3Dendro["children"][0], id2name)
    
    # Output to JSON
    json.dump(d3Dendro, open("%s.json" % fout, "w"), sort_keys=True, indent=4)
    
    # https://bl.ocks.org/mbostock/4339083
    # https://bl.ocks.org/mbostock/4063550


# =============== main function =============== #
# uncomment this part to run this script,
# plotting the dendrogram and converting data2D to json

"""method = "mds"
df_ = pd.read_pickle('pkl/df_before_cluster.pkl')

# get a list of strings, each starts with paper title and its sequence #
brief = ['{} - {} - {}'.format(*t) for t in zip(df_['title'], np.arange(len(df_)), df_['query'])]
# Create dictionary for labeling nodes by their IDs and paper names
id2name = dict(zip(np.arange(len(df_)), brief))

data2D = pd.read_pickle('js/data2D_%s.dat' % method)
linkage_matrix = dendrogram_(data2D, brief, method) # plot the dendrogram

dendro_to_json(linkage_matrix, 'js/hierarchical_%s' % method, id2name)
"""
